这是一款面向 C 端的营销活动类的抽奖系统，实现了抽奖活动的玩法策略创建、参与、记账、发奖逻辑。运营人员可以创建概率类奖品的玩法，拉新用户、留存用户。

<h2 id="WI8XD">DDD 思想以及分层划分</h2>
基于 DDD 进行项目的初始化，一般在公司里面都有专门的脚手架进行搭建

DDD 是一种软件设计思想，开发团队对需要开发的软件进行讨论，将目标分化为一个一个领域，定义好各自的边界（一般使用的是风暴建模法）

类比于 MVC，DDD 也有自己的服务架构

+ 应用层。
    - 用来描述应用和用户行为，负责服务的组合、转发，负责处理执行顺序和组合结果
    - 包括应用服务（组合应用层或者基础层）和消息事件发送和处理
+ 领域层
    - 封装核心业务逻辑
+ 基础层
    - 提供数据库、缓存服务，实现领域层的接口，依赖倒置实现的体现
+ 接口层
    - 处理用户发送的 Restful ，并将信息传递给应用层，处理 HTTP、RPC、参数转换 DTO 转领域对象

和 MVC 的区别：

1. 架构区别：细化了分包，service->领域的拆分，原来每一个数据模型被反复地调用，现在每一个领域有了自己的数据模型，领域中的实体封装了基本的方法。
2. 适用场景：快速迭代简单的小型使用 mvc ，大型的微服务的长期迭代的可以选择使用 DDD 

<h3 id="GnviS">分包-RPC</h3>
RPC 是远程调用服务，允许像调用本地服务一样调用其他服务器的服务，可以类比借书通过打电话。

本质上是 HTTP 序列化实现服务的调用。

常见的 Dubbo、gRPC、Thrift。

<h4 id="P6rc2">RPC 遇到 DDD</h4>
领域中可能互相调用，另外注解污染、复用性问题放在领域中其他服务必须依赖整个领域模块引入了不必要的代码



<h2 id="Keuyj">跑通 RPC</h2>
RPC 的引入，尝试在一个服务中注册数据库服务并且创建一个活动表，同时这个服务提供 Dubbo 接口，另一个服务尝试调用前一个服务的接口。

ps：

1. Dubbo 入参出参以及内部的对象都需要实现 serializable 接口
2. Dubbo 需要使用的接口不是 Spring 的 Service

创建活动表

```sql
CREATE TABLE `activity` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '自增ID',
  `activity_id` bigint(20) NOT NULL COMMENT '活动ID',
  `activity_name` varchar(64) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '活动名称',
  `activity_desc` varchar(128) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '活动描述',
  `begin_date_time` datetime DEFAULT NULL COMMENT '开始时间',
  `end_date_time` datetime DEFAULT NULL COMMENT '结束时间',
  `stock_count` int(11) DEFAULT NULL COMMENT '库存',
  `take_count` int(11) DEFAULT NULL COMMENT '每人可参与次数',
  `state` tinyint(2) DEFAULT NULL COMMENT '活动状态：1编辑、2提审、3撤审、4通过、5运行(审核通过后worker扫描状态)、6拒绝、7关闭、8开启',
  `creator` varchar(64) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '创建人',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_activity_id` (`activity_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='活动配置';

```

把 rpc 独立出来好处就体现了，其他服务使用 rpc 只要一个 jar 包就可以，无需引入额外的无关类。



<h2 id="CLnLe">建表</h2>
抽奖系统需要包括活动表、奖品表、用户参与记录表、用户参与次数表、策略配置、策略明细、用户策略计算结果表

+ 活动表：提供活动的基本信息
+ 策略表：配置抽奖策略，策略描述、计算方法、发奖时间、发奖方式
+ 策略明细：奖品、库存、概率
+ 奖品表：编号、库存、类型、名称、描述
+ 用户参与记录表
+ 用户参与次数表
+ 用户参与结果统计表 中奖信息

用户参与次数表 ~ 用户参与记录表 1vn 的关系 后者是幂等的保证 

<h3 id="jZnpq">为什么要分库分表何时需要分库分表</h3>
解决性能瓶颈，通常数据存储到 200w-300w 就需要考虑，不过一开始也可以设计，一开始拆分都是在虚拟机上，不会造成过大的资源浪费，后续数据上来了，可以迁移到物理机上。分库分表以后由于数据分散，加上负载均衡可以保证请求打在不同的库表上，不至于单表压力过大瘫痪。



对于用户参与记录次数中奖信息高频访问的数据，分库

可以减少 减少物理压力 提高并发连接量

分表可以提高效率 MySQL 的数据结构导致他的层数不能过高，否则会多次 IO 操作

:::info
注意 IO 次数考点

:::

> B+树高度计算
>
> 一页 16kb，叶子节点存数据假设是 1kb，那么一个叶子节点存放的数据有 16kb/1kb=16
>
> 非叶子节点 innodb 中指针在源码中定为 6B，int4B，bigint8B， 16KB/sum
>
> 那么 2 层 的数据是 16*（16kb/（6+8）B）
>
> 3 层是 16*（16kb/（6+8）B）*（16kb/（6+8）B）
>

带来的问题：

1. 分布式事务
2. join 问题
3. 排序
4. 分页
5. id

TPS 打开一个网页 QPS 一个网页可能多个请求 8~10 倍的关系

5000~8000 16g redis <font style="color:rgb(47, 48, 52);"> TPS 8k 左右，qps 8w 差不多有10台-15台虚拟机就够了，4核8G的</font>



MVC ：domain、dao、service、controller

domain 可能很多 没有包的属性 被多个 service 引用 臃肿 

DDD：分领域

一个 domain，多个 model，多个 service，一个仓储 对应一个 dao

<font style="color:rgb(47, 48, 52);"></font>

<h2 id="dbNvs"><font style="color:rgb(47, 48, 52);">抽奖策略？</font></h2>
实际场景中抽奖，运营可能配置不同的策略进行游戏，假设使用了准备了 12 个奖品，每一个奖品配置了不同的中奖概率，当一个奖品被抽空了 --- 剩下的概率是分到其他奖品上，还是保留全部的抽奖的概率，抽到空的表示未中奖呢。

这就体现了不同的策略的运行，我们可以在数据库表设计时要一个对应的字段区分是怎么样的策略。

库表的设计

> 策略表：
>
> 策略 id、策略描述、策略方法（单项概率 | 总体概率）、发奖方式、发奖时间、发奖文案
>
> 策略明细：
>
> 策略 id、奖品 id、奖品库存、概率
>

<h3 id="sYwK6">具体的实现</h3>
两种实现的算法（总体概率和单体概率）：

1. 总体概率 A 发放完毕 B C 按照原来的概率比整体重新分配概率
2. 单项概率 A 发放完 概率不变 抽到 A 显示未中奖
3. 其他：
    1. 动态加权调整：按照个数分配概率
    2. 连续未中奖 下次翻倍
    3. 概率衰减：奖品越少 概率越小 避免过早的所有奖励消耗完
    4. 时间分组
    5. 用户分组

有一个抽奖类作为入口，抽奖类 一个接口定义抽奖方法 继承类进行策略的初始化和检查是否需要元组初始化和基础数据填充

策略类 接口定义随机获取结果 是否存在元组 初始化元组 ；前者的实现在具体的实现类 后两者的实现可以在一个抽象类中因为是公共的方法。

目前两个策略：

1. 初始化的时候分配好概率，通过一个游标递增通过哈希散列 在开始的时候分配好概率 增加随机性 一开始就分配好 后续的话一个随机数看落在那个区间 如果抽到了不存在的区域就是未中奖 o1 时间复杂度
2. 初始化不用初始化，每一个概率连续的占用一段空间 根据当前的剩余可用奖品 计算动态的概率，一定会中奖 on 时间复杂度

<h1 id="gRGpy">模板方法模式抽奖流程</h1>
<h3 id="OEt48">S</h3>
当前的抽奖流程是

1. 获取到当前策略 id 对应的策略
2. 校验和做基本的初始化
3. 排查掉不合适的奖品（没有库存 or 风控方面不能薅羊毛的）
4. 执行抽奖
5. 包装抽奖结果

在实现类中是顺序执行的，当然没有问题，但是不利于维护，不便于在各个节点拓展功能，也容易使得一个类的代码过于庞大。

<h3 id="kFTZl">T</h3>
拓展性增强，可读性增强

<h3 id="d3owt">A</h3>
抽离 DrawExecImpl 的完整实现流程，抽象到上一层抽象类

用模板方法的方式，在抽象类中定义完整的流程

```java
    public DrawResult doDrawExec(DrawReq req) {
        //  获取对应的抽奖策略
        StrategyRich strategyRich = super.queryStrategyRich(req.getStrategyId());
        Strategy strategy = strategyRich.getStrategy();
        //  基本的校验以及初始化
        this.checkAndInitRateData(strategy.getStrategyId(), strategyRich.getStrategyDetailList(), strategy.getStrategyMode());
        //  获取被排除的奖品id（基于库存、风控等）
        List<String> excludeAwardIds = this.queryExcludeAwardIds(strategyRich.getStrategyId());
        //  执行抽奖算法
        String awardId = this.drawAlgorithm(req.getStrategyId(), drawAlgorithmGroup.get(strategy.getStrategyMode()), excludeAwardIds);
        //  包装结果类
        return buildDrawResult(req.getuId(), req.getStrategyId(), awardId);
    }
```

数据获取交由上一层管理，基础校验，包装结果等具有同性的本层处理

执行抽奖算法，排除 id 等可能多种实现的交由子类处理

<h3 id="Ifvwj">R</h3>
基于模板设计模式，规范化抽奖执行流程。包括：提取抽象类、编排模板流程、定义抽象方法、执行抽奖策略、扣减中奖库存、包装返回结果等，并基于P3C标准完善本次开发涉及到的代码规范化处理。



<h1 id="n7xOD">利用简单工厂模式搭建发放奖品领域</h1>
发奖领域主要有两块功能实现，goods 商品处理和 factory 工厂

1. goods：包装适配各类奖品的发放逻辑（调用优惠券、兑换码、发货）
2. factory：调用方提供发奖类型，返回对应的发奖服务

> 策略模式的使用
>
> 1. 早期：照猫画虎--把 service 放入 map 中，通过类加载 写 static 方法导入，代码是冗余的，里面的自动注入是失效了，失效还专门研究了使用导入 class，后续才通过 application 从工厂中实例化
> 2. 后续工作以及平常的代码 遇到了更加优雅的实现 map 中加入@PostConstruct，将 导入交给 spring 管理，这个注解可以在类初始化以后自动做内部的定义的操作。同时策略也不再是使用 service，而是去寻找业务逻辑中的差异 用一个工厂来管理策略
> 3. 比如这个奖品发放、抽奖策略、再到我工作中的多个平台的发布任务（初始化环境、注入 cookie、打开创作中心操作、发表视频、关闭页面、封面文件上传保存临时文件是共性。剩余的可以作为策略独立 不能简单的抽象出一致的操作，结合模板方法）实现职责分离
>

> 工厂方法的使用
>
> 考虑一个分拣中心，各种处理流程（生鲜，家电，文件）如何常规的就是大量的 if-else 臃肿难以维护
>
> 使用工厂以后只需要告诉工厂我需要什么样的包裹，中间的所有结果调用方不需要关心，只需要最后执行一个返回的结果暴露的接口
>
> 具体的策略负责发放，调用方只负责使用，不需要知道细节，拓展性强
>

<h1 id="IkWqW">活动领域的开发</h1>
主要包括活动创建、活动状态处理和用户领取活动

活动的创建需要使用事务（活动系统提供给运营后台创建活动时，需要包括：活动信息、奖品信息、策略信息，需要在一个事务下落库）

活动的审核（编辑、提审、撤审、通过、工作、拒绝、关闭）需要使用状态模式处理

> 循环依赖问题：
>
> A 需要 B，B 需要 A，不知道哪一个需要先被编译
>
> 初始化会异常，可能出现空指针问题，职责混乱
>
> 领域层不应该以来其他的模块
>

> 所谓仓库层  领域层定义了数据操作 具体的实现交由基础建设层 
>
> 仓库的实现需要调用 dao 层
>
> 仓储负责的是领域（可能涉及多个 Dao 的调用） Dao 负责的具体技术（原子操作增删改查） 中间的抽象可以快捷的切换技术 职责分离
>
> 原来 mvc 模式 放在了 service 中
>

主要实现：

1. 通过活动创建聚合根 新增一个活动配置 需要操作到多个表（策略、活动、奖品、策略明细）->使用事务管理
2. 创建活动状态 七大状态 通过 Map 管理 serviceimpl 进行状态的方法执行

极大减少了 if-else 代码冗余 增加可读性 将复杂的转换改造为可读性极强的状态模式



<h1 id="LQQgZ">ID 生成领域</h1>
使用策略模式，提供策略 id 的服务提供，外部调用会根据不同的场景使用不同的 id 生成策略。

对于当前来说，有三种可能的 ID 场景：

+ 订单号：唯一、大量，订单创建时使用，需要分库分表
+ 活动号：唯一、少量，活动创建时使用，不用分库分表
+ 策略号：唯一、少量，活动创建时使用，不用分库分表

对应三种算法：

+ 雪花算法 对应订单号生成  长码 大量
+ 日期算法 对应活动号生成  短码 少量 唯一性自己保证
+ 随机算法 对应策略号生成  短码 大量 唯一性自己保证



